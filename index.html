<!-- index.html ‚Äî Random Live Cams (PLAYER) v2.3.9 (NEWSCAST UI UPGRADE)
  ‚úÖ HUD: sin bot√≥n expandir + sin texto de tiempo (solo progress)
  ‚úÖ VOTE: panel mucho m√°s legible (TV style)
  ‚úÖ Alerts/Points/Ads: estilo unificado + stacking (sin solapes)
  ‚úÖ Fuente noticiero (IBM Plex Sans Condensed / Plex Mono)
  ‚úÖ Mantiene tu bridge/repair/diag y compatibilidad de IDs
-->
<!doctype html>
<html lang="es" data-theme="dark" data-ui="neo-atlas" data-ui-skin="newsroom">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0b0f14" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="robots" content="noindex,nofollow" />
  <meta name="referrer" content="strict-origin-when-cross-origin" />

  <title>Random Live Cams</title>
  <meta name="description" content="Random Live Cams ‚Äî rotaci√≥n de c√°maras con HUD, votaci√≥n por Twitch, chat overlay, alerts, ads notice, ticker y modo cat√°logo." />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VERSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script>
    window.APP_VERSION = "2.3.9";
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VERSION SENTINEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script>
    (() => {
      "use strict";
      try {
        const V = String(window.APP_VERSION || "");
        if (!V) return;

        const K = "rlc_app_version_seen_v1";
        let prev = "";
        try { prev = localStorage.getItem(K) || ""; } catch (_) {}

        if (prev !== V) {
          try { localStorage.setItem(K, V); } catch (_) {}

          const u = new URL(location.href);
          if (!u.searchParams.has("v")) {
            u.searchParams.set("v", V);
            location.replace(u.toString());
            return;
          }
        }

        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistration()
            .then(reg => { try { reg && reg.update && reg.update(); } catch (_) {} })
            .catch(() => {});
        }
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FONTS (NEWSCAST) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Condensed:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet" />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STYLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <link rel="stylesheet" href="./styles.css?v=2.3.9" />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ REPAIR MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       index.html?repair=1
       ‚ö†Ô∏è Limpia SW/caches + localStorage/sessionStorage (incluye tokens). -->
  <script>
    (() => {
      "use strict";
      try {
        const u = new URL(location.href);
        if (!u.searchParams.has("repair")) return;

        const go = async () => {
          try {
            if ("serviceWorker" in navigator) {
              const regs = await navigator.serviceWorker.getRegistrations();
              await Promise.all(regs.map(r => r.unregister()));
            }
          } catch (_) {}

          try {
            if (window.caches && caches.keys) {
              const keys = await caches.keys();
              await Promise.all(keys.map(k => caches.delete(k)));
            }
          } catch (_) {}

          try { localStorage.clear(); } catch (_) {}
          try { sessionStorage.clear(); } catch (_) {}

          u.searchParams.delete("repair");
          u.searchParams.set("v", window.APP_VERSION || "repair");
          location.replace(u.toString());
        };

        go();
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRECONNECTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <link rel="preconnect" href="https://api.gdeltproject.org" crossorigin />
  <link rel="preconnect" href="https://api.mymemory.translated.net" crossorigin />
  <link rel="preconnect" href="https://api.allorigins.win" crossorigin />
  <link rel="preconnect" href="https://r.jina.ai" crossorigin />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LIBS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script defer src="https://cdn.jsdelivr.net/npm/hls.js@1.5.18/dist/hls.min.js"></script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ADMIN CONTROL BRIDGE (PLAYER) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script>
    (() => {
      "use strict";

      const g = (typeof globalThis !== "undefined") ? globalThis : window;

      const BUS_BASE   = "rlc_bus_v1";
      const CMD_BASE   = "rlc_cmd_v1";
      const STATE_BASE = "rlc_state_v1";
      const EVT_BASE   = "rlc_evt_v1";

      const LAST_KEY_STORE = "rlc_last_key_v1";

      const BRIDGE_TAG = "__rlcBridgeHop_v1";
      const SRC_TAG    = "__rlcBridgeSrc_v1";
      const MAX_HOPS   = 1;

      const safeStr = (v) => (typeof v === "string") ? v.trim() : "";
      const isObj = (x) => !!x && typeof x === "object";

      const now = () => Date.now();
      const canBC = ("BroadcastChannel" in window);

      function getUrlKey() {
        try {
          const u = new URL(location.href);
          return safeStr(u.searchParams.get("key") || "");
        } catch (_) { return ""; }
      }

      function getLastKey() {
        try { return safeStr(localStorage.getItem(LAST_KEY_STORE) || ""); } catch (_) { return ""; }
      }

      let KEY = getUrlKey() || getLastKey();

      const BUS_LEGACY = BUS_BASE;
      let   BUS_MAIN   = KEY ? `${BUS_BASE}:${KEY}` : BUS_BASE;

      let bcLegacy = canBC ? new BroadcastChannel(BUS_LEGACY) : null;
      let bcMain   = (canBC && KEY) ? new BroadcastChannel(BUS_MAIN) : null;

      function computeKeys(key) {
        const k = safeStr(key || "");
        return {
          key: k,
          cmdKey:     k ? `${CMD_BASE}:${k}`   : CMD_BASE,
          stateKey:   k ? `${STATE_BASE}:${k}` : STATE_BASE,
          evtKey:     k ? `${EVT_BASE}:${k}`   : EVT_BASE,
          cmdLegacy:   CMD_BASE,
          stateLegacy: STATE_BASE,
          evtLegacy:   EVT_BASE
        };
      }

      let K = computeKeys(KEY);

      const POLL_MS = 250;
      let lastCmdRaw = "";
      let lastStateRaw = "";
      let lastEvtRaw = "";

      function exposeDebug() {
        try {
          g.RLC_KEY = KEY || "";
          g.RLC_BUS = BUS_MAIN || BUS_LEGACY;
          g.RLC_BUS_LEGACY = BUS_LEGACY;
        } catch (_) {}
      }
      exposeDebug();

      function ensureKey(maybeKey) {
        const k = safeStr(maybeKey || "");
        if (!k) return false;
        if (KEY === k && bcMain) return true;

        KEY = k;
        BUS_MAIN = `${BUS_BASE}:${KEY}`;
        K = computeKeys(KEY);

        lastCmdRaw = "";
        lastStateRaw = "";
        lastEvtRaw = "";

        try { localStorage.setItem(LAST_KEY_STORE, KEY); } catch (_) {}

        if (canBC) {
          try { if (bcMain) bcMain.close(); } catch (_) {}
          try { bcMain = new BroadcastChannel(BUS_MAIN); } catch (_) { bcMain = null; }
          if (bcMain) {
            try { bcMain.addEventListener("message", (ev) => onAnyBusMessage(ev, true)); } catch (_) {}
          }
        }

        exposeDebug();
        return true;
      }

      function cloneMsg(msg) {
        try { return structuredClone(msg); }
        catch (_) { return Object.assign({}, msg); }
      }

      function lsSet(k, v) { try { localStorage.setItem(k, v); } catch (_) {} }
      function readLS(k) { try { return localStorage.getItem(k) || ""; } catch (_) { return ""; } }

      function mirrorToStorage(msg) {
        if (!isObj(msg)) return;

        const type = String(msg.type || "").toLowerCase();

        if (!KEY) {
          const mk = safeStr(msg.key || "");
          if (mk) ensureKey(mk);
        }

        let raw = "";
        try { raw = JSON.stringify(msg); } catch (_) { return; }

        if (type === "cmd") {
          lsSet(K.cmdKey, raw);
          lsSet(K.cmdLegacy, raw);
        } else if (type === "state") {
          lsSet(K.stateKey, raw);
          lsSet(K.stateLegacy, raw);
        } else if (type === "event") {
          lsSet(K.evtKey, raw);
          lsSet(K.evtLegacy, raw);
        }
      }

      function forward(targetBc, msg, fromTag) {
        if (!targetBc || !isObj(msg)) return;
        const hop = (msg[BRIDGE_TAG] | 0) || 0;
        if (hop >= MAX_HOPS) return;

        const out = cloneMsg(msg);
        out[BRIDGE_TAG] = hop + 1;
        out[SRC_TAG] = fromTag || out[SRC_TAG] || "bridge";
        if (KEY && !out.key) out.key = KEY;

        try { targetBc.postMessage(out); } catch (_) {}
      }

      function acceptLegacyByKey(msg) {
        if (!KEY) return true;
        const mk = safeStr(msg && msg.key || "");
        if (!mk) return true;
        return mk === KEY;
      }

      function onAnyBusMessage(ev, fromMain) {
        const msg = ev && ev.data;
        if (!isObj(msg)) return;

        if (!fromMain && !acceptLegacyByKey(msg)) return;

        if (!KEY) {
          const mk = safeStr(msg.key || "");
          if (mk) ensureKey(mk);
        }

        mirrorToStorage(msg);

        if (fromMain) forward(bcLegacy, msg, "main->legacy");
        else forward(bcMain, msg, "legacy->main");
      }

      try { if (bcLegacy) bcLegacy.addEventListener("message", (ev) => onAnyBusMessage(ev, false)); } catch (_) {}
      try { if (bcMain)   bcMain.addEventListener("message", (ev) => onAnyBusMessage(ev, true)); } catch (_) {}

      window.addEventListener("message", (ev) => {
        try { if (ev.origin && ev.origin !== location.origin) return; } catch (_) {}

        const msg = ev && ev.data;
        if (!isObj(msg)) return;

        const t = String(msg.type || "").toLowerCase();
        if (t !== "cmd" && t !== "state" && t !== "event") return;

        const mk = safeStr(msg.key || "");
        if (mk) ensureKey(mk);

        if (KEY) {
          const k2 = safeStr(msg.key || "");
          if (k2 && k2 !== KEY) return;
        }

        mirrorToStorage(msg);

        const out = Object.assign({}, msg, { key: KEY || msg.key || "" });
        try { if (bcMain)   bcMain.postMessage(out); } catch (_) {}
        try { if (bcLegacy) bcLegacy.postMessage(out); } catch (_) {}
      }, { passive: true });

      function injectFromLS(raw) {
        if (!raw) return;

        let msg = null;
        try { msg = JSON.parse(raw); } catch (_) { return; }
        if (!isObj(msg)) return;

        const mk = safeStr(msg.key || "");
        if (mk && !KEY) ensureKey(mk);

        if (KEY && mk && mk !== KEY) return;
        if (msg[SRC_TAG] === "ls-poll") return;

        const out = Object.assign({}, msg);
        out[SRC_TAG] = "ls-poll";
        if (KEY && !out.key) out.key = KEY;

        try { if (bcMain)   bcMain.postMessage(out); } catch (_) {}
        try { if (bcLegacy) bcLegacy.postMessage(out); } catch (_) {}
      }

      function pollOnce() {
        const cmdRaw   = readLS(K.cmdKey)   || readLS(K.cmdLegacy);
        const stateRaw = readLS(K.stateKey) || readLS(K.stateLegacy);
        const evtRaw   = readLS(K.evtKey)   || readLS(K.evtLegacy);

        if (cmdRaw && cmdRaw !== lastCmdRaw)         { lastCmdRaw = cmdRaw; injectFromLS(cmdRaw); }
        if (stateRaw && stateRaw !== lastStateRaw)   { lastStateRaw = stateRaw; injectFromLS(stateRaw); }
        if (evtRaw && evtRaw !== lastEvtRaw)         { lastEvtRaw = evtRaw; injectFromLS(evtRaw); }
      }

      window.addEventListener("storage", (e) => {
        if (!e || !e.key) return;

        if (e.key === LAST_KEY_STORE && !KEY) {
          const k = safeStr(e.newValue || "");
          if (k) ensureKey(k);
          return;
        }

        if (e.key === K.cmdKey || e.key === K.cmdLegacy) injectFromLS(e.newValue || "");
        if (e.key === K.stateKey || e.key === K.stateLegacy) injectFromLS(e.newValue || "");
        if (e.key === K.evtKey || e.key === K.evtLegacy) injectFromLS(e.newValue || "");
      });

      try {
        const ping = { type: "event", name: "PLAYER_BOOT", ts: now() };
        if (KEY) ping.key = KEY;
        mirrorToStorage(ping);
        if (bcMain) bcMain.postMessage(ping);
        if (bcLegacy) bcLegacy.postMessage(ping);
      } catch (_) {}

      try { setInterval(pollOnce, POLL_MS); } catch (_) {}

      try {
        const uk = getUrlKey();
        if (uk) localStorage.setItem(LAST_KEY_STORE, uk);
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HARDEN: STAGE / Z-LAYERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <style>
    html, body { height: 100%; }
    body { margin: 0; }

    body{
      min-height:100vh;
      min-height:100svh;
      min-height:100dvh;
      overflow:hidden;
      overscroll-behavior:none;
    }

    #stage{
      isolation:isolate;
      position:relative;
      overflow:hidden;
      height:100vh;
      height:100svh;
      height:100dvh;
    }
    #stage .layer{ position:absolute; inset:0; }
    #stage .layer-media{ z-index:1; }
    #rlcCatalog{ position:absolute; inset:0; z-index:2; display:none; pointer-events:none; }
    #rlcCatalog.on{ display:block; pointer-events:auto; }
    #fallback{ z-index:6; pointer-events:auto; }
    #stage .layer-ui{ z-index:10; }

    /* Tickers arriba (clicables) */
    #rlcNewsTicker{
      position:fixed !important;
      left:10px !important; right:10px !important;
      top:var(--rlcNewsTop, var(--rlcTickerTop,10px)) !important;
      z-index:100 !important;
      pointer-events:auto !important;
    }
    #rlcEconTicker{
      position:fixed !important;
      left:10px !important; right:10px !important;
      top:var(--rlcEconTop,
        calc(
          var(--rlcNewsTop, var(--rlcTickerTop,10px))
          + var(--rlcBarH,34px)
          + var(--rlcTickerGap, var(--rlcEconGap,6px))
        )
      ) !important;
      z-index:99 !important;
      pointer-events:auto !important;
    }

    /* Countdown overlay */
    #rlcCountdown{
      position:fixed; z-index:70;
      top:calc(max(12px, env(safe-area-inset-top)) + var(--ui-top-offset, 0px));
      right:max(14px, env(safe-area-inset-right));
      pointer-events:none;
    }
  </style>
</head>

<body class="mode-player">
  <main id="app" class="app" role="application" aria-label="Random Live Cams">
    <section id="stage" class="stage" aria-label="Reproductor de c√°mara">
      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MEDIA LAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div class="layer layer-media" aria-hidden="true">
        <div id="rlcCatalog" aria-hidden="true"></div>

        <iframe
          id="frame"
          class="media hidden"
          title="Live Cam"
          referrerpolicy="strict-origin-when-cross-origin"
          allow="autoplay; encrypted-media; picture-in-picture; fullscreen"
          allowfullscreen
        ></iframe>

        <video id="video" class="media hidden" autoplay muted playsinline webkit-playsinline></video>
        <img id="img" class="media hidden" alt="Webcam snapshot" decoding="async" />
      </div>

      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FALLBACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div id="fallback" class="fallback hidden" role="status" aria-live="polite">
        <div class="fallbackCard">
          <div class="fallbackTitle">No se puede mostrar esta c√°mara aqu√≠</div>
          <div class="fallbackText">Puede estar offline o bloquear el embed. Saltando‚Ä¶</div>
          <a id="fallbackLink" class="btn" href="#" target="_blank" rel="noopener">Ver en origen</a>
        </div>
      </div>

      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UI LAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div class="layer layer-ui" aria-label="Overlays">
        <!-- HUD -->
        <!-- ‚úÖ Sin hud--collapsed por defecto (mejor info panel) -->
        <div id="hud" class="hud" aria-label="HUD stream">
          <div class="hudBar">
            <div class="hudLeft" id="hudLeft">
              <div class="badge" id="badgeLive">LIVE</div>
              <div class="hudTitle" id="hudTitle" data-title="Cargando‚Ä¶" data-marquee="0">Cargando‚Ä¶</div>

              <div id="rlcHudWx" class="wxOff" aria-live="polite">
                <span id="rlcHudWxIcon" aria-hidden="true">üå°Ô∏è</span>
                <span id="rlcHudWxTemp" class="wxTemp">‚Äî¬∞C</span>
                <span class="wxDot" aria-hidden="true">¬∑</span>
                <span id="rlcHudWxTime" class="wxTime">--:--</span>
              </div>
            </div>

            <!-- ‚úÖ Mantenido por compat, pero oculto (CSS) -->
            <div class="hudRight" aria-hidden="true">
              <div class="hudCountdown mono hidden" id="hudCountdown">05:00</div>
              <button id="hudToggle" class="hudToggle hidden" type="button" aria-label="Expandir HUD" aria-expanded="false">‚ñ∏</button>
            </div>
          </div>

          <div class="progress" aria-hidden="true">
            <div id="progressBar" class="progressBar"></div>
          </div>

          <div id="hudDetails" class="hudDetails">
            <div class="hudRow">
              <div class="hudLabel">Lugar</div>
              <div class="hudValue" id="hudPlace">‚Äî</div>
            </div>

            <div class="hudRow">
              <div class="hudLabel">Fuente</div>
              <div class="hudValue">
                <span id="hudSource">‚Äî</span>
                <span class="dot">‚Ä¢</span>
                <a id="hudOrigin" class="hudLink" href="#" target="_blank" rel="noopener">Origen</a>
              </div>
            </div>

            <div class="hudFooter">
              <span id="hudIndex">‚Äî</span>
              <span class="dot">‚Ä¢</span>
              <span class="muted">N siguiente ¬∑ P anterior ¬∑ Espacio pausa ¬∑ C chat</span>
            </div>
          </div>
        </div>

        <!-- Countdown -->
        <div id="rlcCountdown" class="hidden tr" aria-live="polite">
          <div class="lbl" id="rlcCountdownLabel">FIN DE A√ëO</div>
          <div class="time mono" id="rlcCountdownTime">--:--:--</div>
        </div>

        <!-- Vote -->
        <div id="voteBox" class="vote hidden" aria-label="Votaci√≥n del chat" aria-live="polite">
          <div class="voteTop">
            <div class="voteTitle">VOTACI√ìN</div>
            <div class="voteTime mono" id="voteTime">00:20</div>
          </div>
          <div class="voteHint" id="voteHint">Votaci√≥n en‚Ä¶</div>
          <div class="voteBars">
            <div class="voteBar">
              <div class="voteBarFill" id="voteYes"></div>
              <div class="voteBarLabel"><span>NEXT</span><span id="voteYesN">0</span></div>
            </div>
            <div class="voteBar">
              <div class="voteBarFill no" id="voteNo"></div>
              <div class="voteBarLabel"><span>STAY</span><span id="voteNoN">0</span></div>
            </div>
          </div>
        </div>

        <!-- Chat -->
        <div id="rlcChatRoot" class="rlcChatRoot" aria-label="Chat overlay" aria-live="polite">
          <div id="rlcChatList"></div>
        </div>
      </div>

      <audio id="bgm" preload="auto" crossorigin="anonymous"></audio>
    </section>

    <noscript>
      <section class="fallback" style="position:fixed; inset:0; z-index:9999">
        <div class="fallbackCard">
          <div class="fallbackTitle">JavaScript desactivado</div>
          <div class="fallbackText">Este reproductor necesita JavaScript para rotar c√°maras y mostrar overlays.</div>
        </div>
      </section>
    </noscript>
  </main>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TICKER ROOTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div id="rlcNewsTicker" aria-label="News ticker" aria-live="polite"></div>
  <div id="rlcEconTicker" aria-label="Econ ticker" aria-live="polite"></div>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DIAGN√ìSTICO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div id="rlcDiag" aria-live="polite">
    <div class="card">
      <div class="hdr">Diagn√≥stico (PLAYER)</div>
      <pre id="rlcDiagText"></pre>
      <div class="tip">Tip: prueba <b>index.html?repair=1</b> para limpiar cach√©s y reset total.</div>
    </div>
  </div>

  <!-- Captura errores JS y los muestra en pantalla (PLAYER) -->
  <script>
    (() => {
      "use strict";
      const qs = (s) => document.querySelector(s);

      const showDiag = (msg) => {
        const box = qs("#rlcDiag");
        const pre = qs("#rlcDiagText");
        if (pre) pre.textContent = String(msg || "");
        if (box) box.classList.add("on");
      };

      window.addEventListener("error", (e) => {
        try {
          const lines = [
            `[${new Date().toISOString()}] window.error`,
            `message: ${String(e.message || "")}`,
            `file: ${String(e.filename || "")}:${String(e.lineno || "")}:${String(e.colno || "")}`,
            `stack: ${e.error && e.error.stack ? e.error.stack : "(no stack)"}`
          ];
          showDiag(lines.join("\n"));
        } catch (_) {}
      });

      window.addEventListener("unhandledrejection", (e) => {
        try {
          const r = e.reason;
          const text = (r && (r.stack || r.message)) ? (r.stack || r.message) : String(r);
          showDiag(`[${new Date().toISOString()}] unhandledrejection\n${text}`);
        } catch (_) {}
      });
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATA + MODULES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script defer src="./cams.js?v=2.3.9"></script>
  <script defer src="./music.js?v=2.3.9"></script>
  <script defer src="./weatherClock.js?v=2.3.9"></script>
  <script defer src="./rlcTickers.js?v=2.3.9"></script>
  <script defer src="./catalogView.js?v=2.3.9"></script>
  <script defer src="./pointsControl.js?v=2.3.9"></script>
  <script defer src="./app.js?v=2.3.9"></script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTDOWN BOOTSTRAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script>
    (() => {
      "use strict";

      const g = (typeof globalThis !== "undefined") ? globalThis : window;
      const LOAD_GUARD = "__RLC_COUNTDOWN_BOOT_V110";
      try { if (g[LOAD_GUARD]) return; g[LOAD_GUARD] = true; } catch (_) {}

      const BUS_BASE = "rlc_bus_v1";
      const CD_KEY_BASE = "rlc_countdown_cfg_v1";
      const LAST_KEY_STORE = "rlc_last_key_v1";

      const qs = (s, r = document) => r.querySelector(s);
      const safeStr = (v) => (typeof v === "string") ? v.trim() : "";

      function parseParams() {
        const u = new URL(location.href);
        const countdown = safeStr(u.searchParams.get("countdown") || "");

        const keyFromUrl = safeStr(u.searchParams.get("key") || "");
        const keyFromStore = (() => { try { return safeStr(localStorage.getItem(LAST_KEY_STORE) || ""); } catch (_) { return ""; } })();
        const key = keyFromUrl || keyFromStore;

        const toA = safeStr(u.searchParams.get("countdownTo") || "");
        const toB = safeStr(u.searchParams.get("countTo") || "");
        const toC = safeStr(u.searchParams.get("countdownTarget") || "");

        const labelA = safeStr(u.searchParams.get("countdownLabel") || "");
        const labelB = safeStr(u.searchParams.get("countLabel") || "");

        const posA = safeStr(u.searchParams.get("countdownPos") || "");
        const posB = safeStr(u.searchParams.get("countPos") || "");

        return {
          key,
          countdown,
          countdownTo: toC || toA || toB,
          countdownLabel: labelA || labelB,
          countdownPos: posA || posB
        };
      }

      const P = parseParams();
      const KEY = P.key;

      const BUS = KEY ? `${BUS_BASE}:${KEY}` : BUS_BASE;
      const BUS_LEGACY = BUS_BASE;

      const CD_KEY = KEY ? `${CD_KEY_BASE}:${KEY}` : CD_KEY_BASE;
      const CD_KEY_LEGACY = CD_KEY_BASE;

      const bcMain = ("BroadcastChannel" in window) ? new BroadcastChannel(BUS) : null;
      const bcLegacy = (("BroadcastChannel" in window) && KEY) ? new BroadcastChannel(BUS_LEGACY) : null;

      function keyOk(msg, isMain) {
        if (!KEY) return true;
        if (isMain) return true;
        const mk = safeStr(msg && msg.key || "");
        if (!mk) return true;
        return mk === KEY;
      }

      const DEFAULTS = {
        enabled: false,
        label: "FIN DE A√ëO",
        targetMs: 0,
        targetIso: "",
        position: "tr",
        hideHudWhenCatalog: true
      };

      function readJson(key) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          return (obj && typeof obj === "object") ? obj : null;
        } catch (_) { return null; }
      }

      function normalizeCfg(inCfg) {
        const c = Object.assign({}, DEFAULTS, inCfg || {});
        c.enabled = (c.enabled === true);

        c.label = safeStr(c.label || DEFAULTS.label).slice(0, 60) || DEFAULTS.label;
        c.position = (c.position === "tl" || c.position === "tr" || c.position === "bl" || c.position === "br") ? c.position : "tr";
        c.hideHudWhenCatalog = (c.hideHudWhenCatalog !== false);

        const ms = (typeof c.targetMs === "number") ? c.targetMs : parseInt(String(c.targetMs || "0"), 10);
        c.targetMs = Number.isFinite(ms) ? Math.max(0, ms) : 0;
        c.targetIso = safeStr(c.targetIso || "");

        if (!c.targetMs && /^\d{10,13}$/.test(c.targetIso)) {
          const n = parseInt(c.targetIso, 10);
          if (Number.isFinite(n)) c.targetMs = (String(n).length === 10) ? (n * 1000) : n;
          c.targetIso = "";
        }

        return c;
      }

      function cfgFromUrlParams() {
        const on = (P.countdown === "1" || P.countdown === "true");
        if (!on && !P.countdownTo && !P.countdownLabel) return null;

        let targetMs = 0;
        const rawTo = safeStr(P.countdownTo || "");

        if (rawTo) {
          if (/^\d{10,13}$/.test(rawTo)) {
            const n = parseInt(rawTo, 10);
            if (Number.isFinite(n)) targetMs = (String(n).length === 10) ? (n * 1000) : n;
          } else {
            const d = new Date(rawTo);
            const ms = d.getTime();
            if (Number.isFinite(ms) && ms > 0) targetMs = ms;
          }
        }

        return normalizeCfg({
          enabled: on || !!targetMs,
          label: P.countdownLabel || DEFAULTS.label,
          targetMs,
          position: P.countdownPos || "tr"
        });
      }

      function loadCfg() {
        const stored = readJson(CD_KEY) || readJson(CD_KEY_LEGACY);
        const urlCfg = cfgFromUrlParams();
        return normalizeCfg(stored || urlCfg || DEFAULTS);
      }

      let CFG = loadCfg();

      const root = qs("#rlcCountdown");
      const elLbl = qs("#rlcCountdownLabel");
      const elTime = qs("#rlcCountdownTime");
      const hud = qs("#hud");

      let targetMs = 0;

      function setPos(pos) {
        if (!root) return;
        root.classList.remove("tr", "tl", "br", "bl");
        root.classList.add(pos || "tr");
      }

      function show(on) {
        if (!root) return;
        root.classList.toggle("hidden", !on);
      }

      function nextNewYearLocalMs() {
        try {
          const now = new Date();
          const y = now.getFullYear() + 1;
          return new Date(y, 0, 1, 0, 0, 0, 0).getTime();
        } catch (_) { return 0; }
      }

      function applyCfg(cfg) {
        CFG = normalizeCfg(cfg);

        if (elLbl) elLbl.textContent = CFG.label || DEFAULTS.label;
        setPos(CFG.position || "tr");

        targetMs = CFG.targetMs || 0;
        if (!targetMs && CFG.targetIso) {
          const d = new Date(CFG.targetIso);
          const ms = d.getTime();
          if (Number.isFinite(ms) && ms > 0) targetMs = ms;
        }
        if (!targetMs && CFG.enabled) targetMs = nextNewYearLocalMs();

        show(!!(CFG.enabled && targetMs > 0));
      }

      function fmtRemain(ms) {
        ms = Math.max(0, ms | 0);
        const sec = (ms / 1000) | 0;
        const d = (sec / 86400) | 0;
        const h = ((sec % 86400) / 3600) | 0;
        const m = ((sec % 3600) / 60) | 0;
        const s = sec % 60;

        const pad = (n) => String(n).padStart(2, "0");
        if (d > 0) return `${d}d ${pad(h)}:${pad(m)}:${pad(s)}`;
        return `${pad(h)}:${pad(m)}:${pad(s)}`;
      }

      function isCatalogOn() {
        const c = qs("#rlcCatalog");
        return !!(c && c.classList.contains("on"));
      }

      function tick() {
        try {
          if (hud && CFG.hideHudWhenCatalog) {
            hud.style.display = isCatalogOn() ? "none" : "";
          }
        } catch (_) {}

        if (!root || root.classList.contains("hidden")) return;
        if (!targetMs) return;

        const ms = targetMs - Date.now();
        if (ms <= 0) {
          if (elTime) elTime.textContent = "üéâ 00:00:00";
          if (elLbl) elLbl.textContent = "FELIZ A√ëO NUEVO";
          return;
        }

        if (elTime) elTime.textContent = fmtRemain(ms);
      }

      function onBusMessage(msg, isMain) {
        if (!msg || typeof msg !== "object") return;

        if (msg.type === "COUNTDOWN_CFG" && msg.cfg && typeof msg.cfg === "object") {
          if (!keyOk(msg, isMain)) return;
          applyCfg(msg.cfg);
          return;
        }

        if (msg.type === "cmd" && (msg.cmd === "COUNTDOWN_SET" || msg.name === "COUNTDOWN_SET") && msg.payload && typeof msg.payload === "object") {
          if (!keyOk(msg, isMain)) return;
          applyCfg(msg.payload);
          return;
        }
      }

      if (bcMain) bcMain.addEventListener("message", (ev) => onBusMessage(ev?.data, true));
      if (bcLegacy) bcLegacy.addEventListener("message", (ev) => onBusMessage(ev?.data, false));

      window.addEventListener("storage", (e) => {
        if (!e || !e.key) return;
        if (e.key === CD_KEY || e.key === CD_KEY_LEGACY) applyCfg(loadCfg());
      });

      function boot() {
        applyCfg(loadCfg());
        tick();
        setInterval(tick, 250);
      }

      if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", boot, { once: true });
      else boot();
    })();
  </script>
</body>
</html>

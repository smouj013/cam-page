<!-- index.html ‚Äî Random Live Cams (PLAYER) v2.3.9 (HARDENED + KEYED BUS + REPAIR + DIAG)
  ‚úÖ Compatible con tu stack actual:
     - styles.css, cams.js, music.js, weatherClock.js, rlcTickers.js, catalogView.js, pointsControl.js, app.js
  ‚úÖ Compatible con cams.js v2.3.9 (VIDEO ONLY + AUTO-DISCOVERY + CATALOG 4-UP + OPTIONAL NEWS):
     - window.CAM_LIST / CAM_CATALOG_LIST / CAM_NEWS_LIST / CAM_LIST_READY
     - evento "rlc_cam_list_updated"
     - window.RLCCams.* (refresh/clearCache/setTarget/setAutoDiscovery/setValidateEmbed + News setters)
     - BroadcastChannel: rlc_bus_v1 y rlc_bus_v1:{key}
  ‚úÖ Control panel robusto:
     - Legacy bus SIEMPRE: rlc_bus_v1
     - Keyed bus din√°mico: rlc_bus_v1:{key} (URL ?key= | localStorage rlc_last_key_v1 | msg.key)
     - Mirror LS cmd/state/evt keyed <-> legacy
     - Polling LS + reinyecci√≥n a BC (por si BC/storage fallan)
     - postMessage same-origin (cmd/state/event)
  ‚úÖ Version sentinel: alinear v=APP_VERSION sin borrar tokens
  ‚úÖ REPAIR MODE: ?repair=1 (limpia SW/caches/storage bajo demanda)
  ‚úÖ Diagn√≥stico en pantalla (window.error + unhandledrejection)
  ‚úÖ FIX IMPORTANTE (v2.3.9): Countdown sin overflow 32-bit (NO usa |0 en duraciones largas)
-->
<!doctype html>
<html lang="es" data-theme="dark" data-ui="neo-atlas" data-ui-skin="newsroom">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0b0f14" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="robots" content="noindex,nofollow" />
  <meta name="referrer" content="strict-origin-when-cross-origin" />

  <title>Random Live Cams</title>
  <meta name="description" content="Random Live Cams ‚Äî rotaci√≥n de c√°maras con HUD, votaci√≥n por Twitch, chat overlay, alerts, ads notice, ticker y modo cat√°logo." />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VERSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script>
    // Mant√©n esto alineado con tus assets locales (?v=)
    window.APP_VERSION = "2.3.9";
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VERSION SENTINEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       Recarga suave si cambia APP_VERSION (NO borra storage / NO toca tokens).
       Tambi√©n pide update del SW si existiera uno registrado. -->
  <script>
    (() => {
      "use strict";
      try {
        const V = String(window.APP_VERSION || "");
        if (!V) return;

        const K = "rlc_app_version_seen_v1";
        let prev = "";
        try { prev = localStorage.getItem(K) || ""; } catch (_) {}

        if (prev !== V) {
          try { localStorage.setItem(K, V); } catch (_) {}

          const u = new URL(location.href);
          if (!u.searchParams.has("v")) {
            u.searchParams.set("v", V);
            location.replace(u.toString());
            return;
          }
        }

        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistration()
            .then(reg => { try { reg && reg.update && reg.update(); } catch (_) {} })
            .catch(() => {});
        }
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STYLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <link rel="stylesheet" href="./styles.css?v=2.3.9" />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ REPAIR MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       index.html?repair=1
       ‚ö†Ô∏è Esto S√ç limpia localStorage/sessionStorage (incluye tokens). √ösalo solo si quieres reset total. -->
  <script>
    (() => {
      "use strict";
      try {
        const u = new URL(location.href);
        if (!u.searchParams.has("repair")) return;

        const go = async () => {
          try {
            if ("serviceWorker" in navigator) {
              const regs = await navigator.serviceWorker.getRegistrations();
              await Promise.all(regs.map(r => r.unregister()));
            }
          } catch (_) {}

          try {
            if (window.caches && caches.keys) {
              const keys = await caches.keys();
              await Promise.all(keys.map(k => caches.delete(k)));
            }
          } catch (_) {}

          try { localStorage.clear(); } catch (_) {}
          try { sessionStorage.clear(); } catch (_) {}

          u.searchParams.delete("repair");
          u.searchParams.set("v", window.APP_VERSION || "repair");
          location.replace(u.toString());
        };

        go();
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRECONNECTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <link rel="preconnect" href="https://api.gdeltproject.org" crossorigin />
  <link rel="preconnect" href="https://api.mymemory.translated.net" crossorigin />
  <link rel="preconnect" href="https://api.allorigins.win" crossorigin />
  <link rel="preconnect" href="https://r.jina.ai" crossorigin />

  <!-- cams.js autodiscovery (Invidious + YouTube thumbs) -->
  <link rel="preconnect" href="https://api.invidious.io" crossorigin />
  <link rel="preconnect" href="https://i.ytimg.com" crossorigin />
  <link rel="preconnect" href="https://www.youtube.com" crossorigin />

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LIBS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <!-- hls.js (solo si usas cams HLS .m3u8) -->
  <script defer src="https://cdn.jsdelivr.net/npm/hls.js@1.5.18/dist/hls.min.js"></script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ADMIN CONTROL BRIDGE (PLAYER) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script>
    (() => {
      "use strict";

      const g = (typeof globalThis !== "undefined") ? globalThis : window;

      // Base keys
      const BUS_BASE   = "rlc_bus_v1";
      const CMD_BASE   = "rlc_cmd_v1";
      const STATE_BASE = "rlc_state_v1";
      const EVT_BASE   = "rlc_evt_v1";

      const LAST_KEY_STORE = "rlc_last_key_v1";

      // Loop protection
      const BRIDGE_TAG = "__rlcBridgeHop_v1";
      const SRC_TAG    = "__rlcBridgeSrc_v1";
      const MAX_HOPS   = 1;

      const safeStr = (v) => (typeof v === "string") ? v.trim() : "";
      const isObj = (x) => !!x && typeof x === "object";

      const now = () => Date.now();
      const canBC = ("BroadcastChannel" in window);

      function getUrlKey() {
        try {
          const u = new URL(location.href);
          return safeStr(u.searchParams.get("key") || "");
        } catch (_) { return ""; }
      }

      function getLastKey() {
        try { return safeStr(localStorage.getItem(LAST_KEY_STORE) || ""); } catch (_) { return ""; }
      }

      // KEY: URL > lastKey (engancha aunque abras sin ?key=)
      let KEY = getUrlKey() || getLastKey();

      const BUS_LEGACY = BUS_BASE;
      let   BUS_MAIN   = KEY ? `${BUS_BASE}:${KEY}` : BUS_BASE;

      let bcLegacy = canBC ? new BroadcastChannel(BUS_LEGACY) : null;
      let bcMain   = (canBC && KEY) ? new BroadcastChannel(BUS_MAIN) : null;

      function computeKeys(key) {
        const k = safeStr(key || "");
        return {
          key: k,
          cmdKey:     k ? `${CMD_BASE}:${k}`   : CMD_BASE,
          stateKey:   k ? `${STATE_BASE}:${k}` : STATE_BASE,
          evtKey:     k ? `${EVT_BASE}:${k}`   : EVT_BASE,
          cmdLegacy:   CMD_BASE,
          stateLegacy: STATE_BASE,
          evtLegacy:   EVT_BASE
        };
      }

      let K = computeKeys(KEY);

      // Poll state (se resetea al cambiar KEY para no ‚Äúcomerse‚Äù el primer cmd)
      const POLL_MS = 250;
      let lastCmdRaw = "";
      let lastStateRaw = "";
      let lastEvtRaw = "";

      function exposeDebug() {
        try {
          g.RLC_KEY = KEY || "";
          g.RLC_BUS = BUS_MAIN || BUS_LEGACY;
          g.RLC_BUS_LEGACY = BUS_LEGACY;
        } catch (_) {}
      }
      exposeDebug();

      function ensureKey(maybeKey) {
        const k = safeStr(maybeKey || "");
        if (!k) return false;
        if (KEY === k && bcMain) return true;

        KEY = k;
        BUS_MAIN = `${BUS_BASE}:${KEY}`;
        K = computeKeys(KEY);

        // reset poll memory para que el primer snapshot ‚Äúentre‚Äù
        lastCmdRaw = "";
        lastStateRaw = "";
        lastEvtRaw = "";

        try { localStorage.setItem(LAST_KEY_STORE, KEY); } catch (_) {}

        if (canBC) {
          try { if (bcMain) bcMain.close(); } catch (_) {}
          try { bcMain = new BroadcastChannel(BUS_MAIN); } catch (_) { bcMain = null; }
          if (bcMain) {
            try { bcMain.addEventListener("message", (ev) => onAnyBusMessage(ev, true)); } catch (_) {}
          }
        }

        exposeDebug();
        return true;
      }

      function cloneMsg(msg) {
        try { return structuredClone(msg); }
        catch (_) { return Object.assign({}, msg); }
      }

      function lsSet(k, v) { try { localStorage.setItem(k, v); } catch (_) {} }
      function readLS(k) { try { return localStorage.getItem(k) || ""; } catch (_) { return ""; } }

      function mirrorToStorage(msg) {
        if (!isObj(msg)) return;

        const type = String(msg.type || "").toLowerCase();

        // Si viene key dentro del msg y a√∫n no ten√≠amos KEY, adoptarla
        if (!KEY) {
          const mk = safeStr(msg.key || "");
          if (mk) ensureKey(mk);
        }

        let raw = "";
        try { raw = JSON.stringify(msg); } catch (_) { return; }

        if (type === "cmd") {
          lsSet(K.cmdKey, raw);
          lsSet(K.cmdLegacy, raw);
        } else if (type === "state") {
          lsSet(K.stateKey, raw);
          lsSet(K.stateLegacy, raw);
        } else if (type === "event") {
          lsSet(K.evtKey, raw);
          lsSet(K.evtLegacy, raw);
        }
      }

      function forward(targetBc, msg, fromTag) {
        if (!targetBc || !isObj(msg)) return;
        const hop = (msg[BRIDGE_TAG] | 0) || 0;
        if (hop >= MAX_HOPS) return;

        const out = cloneMsg(msg);
        out[BRIDGE_TAG] = hop + 1;
        out[SRC_TAG] = fromTag || out[SRC_TAG] || "bridge";

        // a√±ade key si existe
        if (KEY && !out.key) out.key = KEY;

        try { targetBc.postMessage(out); } catch (_) {}
      }

      function acceptLegacyByKey(msg) {
        // Si estamos en KEY mode, del legacy aceptamos:
        // - msg.key vac√≠o (control viejo)
        // - o msg.key === KEY
        if (!KEY) return true;
        const mk = safeStr(msg && msg.key || "");
        if (!mk) return true;
        return mk === KEY;
      }

      function onAnyBusMessage(ev, fromMain) {
        const msg = ev && ev.data;
        if (!isObj(msg)) return;

        // Si llega por legacy y no cuadra la key, ignora.
        if (!fromMain && !acceptLegacyByKey(msg)) return;

        // Si llega por legacy con key y no tenemos KEY, adoptarla
        if (!KEY) {
          const mk = safeStr(msg.key || "");
          if (mk) ensureKey(mk);
        }

        mirrorToStorage(msg);

        // forward al otro bus
        if (fromMain) forward(bcLegacy, msg, "main->legacy");
        else forward(bcMain, msg, "legacy->main");
      }

      try { if (bcLegacy) bcLegacy.addEventListener("message", (ev) => onAnyBusMessage(ev, false)); } catch (_) {}
      try { if (bcMain)   bcMain.addEventListener("message", (ev) => onAnyBusMessage(ev, true)); } catch (_) {}

      // Acepta postMessage desde preview/control (same-origin), y lo mete en el bus + storage
      window.addEventListener("message", (ev) => {
        try {
          if (ev.origin && ev.origin !== location.origin) return;
        } catch (_) {}

        const msg = ev && ev.data;
        if (!isObj(msg)) return;

        const t = String(msg.type || "").toLowerCase();
        if (t !== "cmd" && t !== "state" && t !== "event") return;

        const mk = safeStr(msg.key || "");
        if (mk) ensureKey(mk);

        // si tenemos KEY y msg trae una key distinta, ignora
        if (KEY) {
          const k2 = safeStr(msg.key || "");
          if (k2 && k2 !== KEY) return;
        }

        mirrorToStorage(msg);

        // post a BCs
        const out = Object.assign({}, msg, { key: KEY || msg.key || "" });
        try { if (bcMain)   bcMain.postMessage(out); } catch (_) {}
        try { if (bcLegacy) bcLegacy.postMessage(out); } catch (_) {}
      }, { passive: true });

      // Polling LS: reinyecci√≥n a BC para que app.js vea cmd/state/event aunque BC/storage no disparen.
      // (Esto NO ejecuta nada por s√≠ mismo: solo re-publica al canal que ya escucha tu app.js)
      function injectFromLS(raw) {
        if (!raw) return;

        let msg = null;
        try { msg = JSON.parse(raw); } catch (_) { return; }
        if (!isObj(msg)) return;

        const mk = safeStr(msg.key || "");
        if (mk && !KEY) ensureKey(mk);

        if (KEY && mk && mk !== KEY) return;

        // evita loops: marca fuente LS
        if (msg[SRC_TAG] === "ls-poll") return;

        const out = Object.assign({}, msg);
        out[SRC_TAG] = "ls-poll";
        if (KEY && !out.key) out.key = KEY;

        try { if (bcMain)   bcMain.postMessage(out); } catch (_) {}
        try { if (bcLegacy) bcLegacy.postMessage(out); } catch (_) {}
      }

      function pollOnce() {
        // Prioriza KEYED si existe, si no, legacy
        const cmdRaw   = readLS(K.cmdKey)   || readLS(K.cmdLegacy);
        const stateRaw = readLS(K.stateKey) || readLS(K.stateLegacy);
        const evtRaw   = readLS(K.evtKey)   || readLS(K.evtLegacy);

        if (cmdRaw && cmdRaw !== lastCmdRaw)         { lastCmdRaw = cmdRaw; injectFromLS(cmdRaw); }
        if (stateRaw && stateRaw !== lastStateRaw)   { lastStateRaw = stateRaw; injectFromLS(stateRaw); }
        if (evtRaw && evtRaw !== lastEvtRaw)         { lastEvtRaw = evtRaw; injectFromLS(evtRaw); }
      }

      // storage event (√∫til entre pesta√±as)
      window.addEventListener("storage", (e) => {
        if (!e || !e.key) return;

        // si cambia last key, podemos adoptar (solo si a√∫n no hay KEY)
        if (e.key === LAST_KEY_STORE && !KEY) {
          const k = safeStr(e.newValue || "");
          if (k) ensureKey(k);
          return;
        }

        // si cambian cmd/state/evt, fuerza inject
        if (e.key === K.cmdKey || e.key === K.cmdLegacy) injectFromLS(e.newValue || "");
        if (e.key === K.stateKey || e.key === K.stateLegacy) injectFromLS(e.newValue || "");
        if (e.key === K.evtKey || e.key === K.evtLegacy) injectFromLS(e.newValue || "");
      });

      // Kick suave: publica boot event (para que control sepa que hay player)
      try {
        const ping = { type: "event", name: "PLAYER_BOOT", ts: now() };
        if (KEY) ping.key = KEY;
        mirrorToStorage(ping);
        if (bcMain) bcMain.postMessage(ping);
        if (bcLegacy) bcLegacy.postMessage(ping);
      } catch (_) {}

      // Arranca polling
      try { setInterval(pollOnce, POLL_MS); } catch (_) {}

      // Guarda last key si ven√≠a por URL (para ayudar al control)
      try {
        const uk = getUrlKey();
        if (uk) localStorage.setItem(LAST_KEY_STORE, uk);
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HARDEN: LAYERS + TICKERS TOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <style>
    html, body { height: 100%; }
    body { margin: 0; }

    body{
      min-height:100vh;
      min-height:100svh;
      min-height:100dvh;
      overflow:hidden;
      overscroll-behavior:none;
    }

    #stage{
      isolation:isolate;
      position:relative;
      overflow:hidden;
      height:100vh;
      height:100svh;
      height:100dvh;
    }
    #stage .layer{ position:absolute; inset:0; }
    #stage .layer-media{ z-index:1; }
    #rlcCatalog{ position:absolute; inset:0; z-index:2; display:none; pointer-events:none; }
    #rlcCatalog.on{ display:block; pointer-events:auto; }
    #fallback{ z-index:5; pointer-events:auto; position:absolute; inset:0; }
    #stage .layer-ui{ z-index:10; }

    /* Tickers SIEMPRE arriba */
    #rlcNewsTicker{
      position:fixed!important;
      left:10px!important; right:10px!important;
      top:var(--rlcNewsTop, var(--rlcTickerTop,10px))!important;
      z-index:2147483647!important;
      pointer-events:none!important;
    }
    #rlcEconTicker{
      position:fixed!important;
      left:10px!important; right:10px!important;
      top:var(--rlcEconTop,
        calc(
          var(--rlcNewsTop, var(--rlcTickerTop,10px))
          + var(--rlcBarH,34px)
          + var(--rlcTickerGap, var(--rlcEconGap,6px))
        )
      )!important;
      z-index:2147483646!important;
      pointer-events:none!important;
    }

    /* Countdown overlay */
    #rlcCountdown{
      position:absolute; z-index:50;
      top:calc(max(12px, env(safe-area-inset-top)) + var(--ui-top-offset, 0px));
      right:max(14px, env(safe-area-inset-right));
      display:flex; flex-direction:column; gap:6px;
      padding:10px 12px; border-radius:14px;
      background:linear-gradient(180deg,
        var(--news-bg-top, rgba(10,14,22,.72)),
        var(--news-bg-bot, rgba(10,14,22,.86))
      );
      border:1px solid var(--stroke, rgba(255,255,255,.12));
      backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
      box-shadow:0 18px 55px rgba(0,0,0,.55);
      color:rgba(255,255,255,.94);
      max-width:min(340px, calc(100vw - 24px));
      overflow:hidden;
      pointer-events:none;
    }
    #rlcCountdown.hidden{ display:none; }
    #rlcCountdown .lbl{
      font:950 12px/1 ui-sans-serif,system-ui;
      letter-spacing:.14em;
      opacity:.92;
      text-transform:uppercase;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      display:flex; align-items:center; gap:8px;
    }
    #rlcCountdown .lbl::before{
      content:"";
      width:8px; height:8px; border-radius:999px;
      background:var(--news-red, #ff375f);
      box-shadow:0 0 0 3px rgba(255,55,95,.18), 0 0 16px rgba(255,55,95,.45);
    }
    #rlcCountdown .time{
      font:950 20px/1 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      letter-spacing:.02em;
      font-variant-numeric:tabular-nums;
    }
    #rlcCountdown.tr{ top:calc(max(12px, env(safe-area-inset-top)) + var(--ui-top-offset,0px)); right:max(14px, env(safe-area-inset-right)); left:auto; bottom:auto; }
    #rlcCountdown.tl{ top:calc(max(12px, env(safe-area-inset-top)) + var(--ui-top-offset,0px)); left:max(14px, env(safe-area-inset-left)); right:auto; bottom:auto; }
    #rlcCountdown.br{ bottom:max(14px, env(safe-area-inset-bottom)); right:max(14px, env(safe-area-inset-right)); top:auto; left:auto; }
    #rlcCountdown.bl{ bottom:max(14px, env(safe-area-inset-bottom)); left:max(14px, env(safe-area-inset-left)); top:auto; right:auto; }

    /* Diag overlay */
    #rlcDiag{
      position:fixed; inset:14px;
      z-index:2147483645;
      display:none;
      pointer-events:auto;
    }
    #rlcDiag.on{ display:block; }
    #rlcDiag .card{
      max-width:980px;
      margin:0 auto;
      background:rgba(10,14,22,.86);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    #rlcDiag .hdr{
      padding:12px 14px;
      font:950 12px/1 ui-sans-serif,system-ui;
      letter-spacing:.14em;
      text-transform:uppercase;
      background:linear-gradient(90deg, rgba(255,59,59,.20), rgba(55,214,255,.12));
      border-bottom:1px solid rgba(255,255,255,.12);
    }
    #rlcDiag pre{
      margin:0;
      padding:12px 14px;
      white-space:pre-wrap;
      font:600 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      color:rgba(255,255,255,.92);
    }
    #rlcDiag .tip{
      padding:10px 14px 14px;
      color:rgba(255,255,255,.70);
      border-top:1px solid rgba(255,255,255,.10);
      font:650 12px/1.3 ui-sans-serif,system-ui;
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHAT PATCH (v2.3.9) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       Objetivo:
       - Hacer visible el chat cuando est√° ON (por URL o por llegada de mensajes)
       - Soportar wrappers intermedios t√≠picos (.line/.row/.wrap/.inner/...).
       - Forzar que nombre y mensaje sean legibles (sin "position:absolute" heredado raro)
       NO toca tu styles.css, solo refuerza desde el HTML.
    */
    body.chat--on #rlcChatRoot,
    body[data-chat="1"] #rlcChatRoot,
    #rlcChatRoot.chat--on,
    #rlcChatRoot.on,
    #rlcChatRoot.visible{
      display:block !important;
    }

    /* Si tu renderer mete wrappers, los ‚Äúaplanamos‚Äù sin :has */
    #rlcChatList > * > .line,
    #rlcChatList > * > .row,
    #rlcChatList > * > .wrap,
    #rlcChatList > * > .inner,
    #rlcChatList > * > .content,
    #rlcChatList > * > .msgLine,
    #rlcChatList > * > .chatLine,
    #rlcChatList > * > .item,
    #rlcChatList > * > .bubble{
      display: contents;
    }

    /* Hard override: nombre y mensaje SIEMPRE visibles y sin absolutas raras */
    #rlcChatList .name,
    #rlcChatList .user,
    #rlcChatList .author,
    #rlcChatList .nick{
      position: relative !important;
      opacity: 1 !important;
      visibility: visible !important;
      display: inline-flex !important;
      max-width: 100%;
    }
    #rlcChatList .msg,
    #rlcChatList .message,
    #rlcChatList .body{
      position: relative !important;
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
    }
  </style>
</head>

<body class="mode-player">
  <main id="app" class="app" role="application" aria-label="Random Live Cams">
    <section id="stage" class="stage" aria-label="Reproductor de c√°mara">
      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MEDIA LAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div class="layer layer-media" aria-hidden="true">
        <div id="rlcCatalog" aria-hidden="true"></div>

        <iframe
          id="frame"
          class="media hidden"
          title="Live Cam"
          referrerpolicy="strict-origin-when-cross-origin"
          allow="autoplay; encrypted-media; picture-in-picture; fullscreen"
          allowfullscreen
        ></iframe>

        <video id="video" class="media hidden" autoplay muted playsinline webkit-playsinline></video>

        <!-- Mantengo el <img> por compat con tu app.js (aunque cams.js sea VIDEO ONLY, no rompe nada) -->
        <img id="img" class="media hidden" alt="Webcam snapshot" decoding="async" />
      </div>

      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FALLBACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div id="fallback" class="fallback hidden" role="status" aria-live="polite">
        <div class="fallbackCard">
          <div class="fallbackTitle">No se puede mostrar esta c√°mara aqu√≠</div>
          <div class="fallbackText">Puede estar offline o bloquear el embed. Saltando‚Ä¶</div>
          <a id="fallbackLink" class="btn" href="#" target="_blank" rel="noopener">Ver en origen</a>
        </div>
      </div>

      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UI LAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div class="layer layer-ui" aria-label="Overlays">
        <!-- HUD -->
        <div id="hud" class="hud hud--collapsed" aria-label="HUD stream">
          <div class="hudBar">
            <div class="hudLeft" id="hudLeft">
              <div class="badge" id="badgeLive">LIVE</div>
              <div class="hudTitle" id="hudTitle" data-title="Cargando‚Ä¶" data-marquee="0">Cargando‚Ä¶</div>

              <div id="rlcHudWx" class="wxOff" aria-live="polite">
                <span id="rlcHudWxIcon" aria-hidden="true">üå°Ô∏è</span>
                <span id="rlcHudWxTemp" class="wxTemp">‚Äî¬∞C</span>
                <span class="wxDot" aria-hidden="true">¬∑</span>
                <span id="rlcHudWxTime" class="wxTime">--:--</span>
              </div>
            </div>

            <div class="hudRight">
              <div class="hudCountdown mono" id="hudCountdown">05:00</div>
              <button id="hudToggle" class="hudToggle" type="button" aria-label="Expandir HUD" aria-expanded="false">‚ñ∏</button>
            </div>
          </div>

          <div class="progress" aria-hidden="true">
            <div id="progressBar" class="progressBar"></div>
          </div>

          <div id="hudDetails" class="hudDetails">
            <div class="hudRow">
              <div class="hudLabel">Lugar</div>
              <div class="hudValue" id="hudPlace">‚Äî</div>
            </div>

            <div class="hudRow">
              <div class="hudLabel">Fuente</div>
              <div class="hudValue">
                <span id="hudSource">‚Äî</span>
                <span class="dot">‚Ä¢</span>
                <a id="hudOrigin" class="hudLink" href="#" target="_blank" rel="noopener">Origen</a>
              </div>
            </div>

            <div class="hudFooter">
              <span id="hudIndex">‚Äî</span>
              <span class="dot">‚Ä¢</span>
              <span class="muted">Espacio pausa ¬∑ N siguiente ¬∑ P anterior ¬∑ H HUD ¬∑ I detalles ¬∑ C chat</span>
            </div>
          </div>
        </div>

        <!-- Countdown -->
        <div id="rlcCountdown" class="hidden tr" aria-live="polite">
          <div class="lbl" id="rlcCountdownLabel">FIN DE A√ëO</div>
          <div class="time mono" id="rlcCountdownTime">--:--:--</div>
        </div>

        <!-- Vote -->
        <div id="voteBox" class="vote hidden" aria-label="Votaci√≥n del chat" aria-live="polite">
          <div class="voteTop">
            <div class="voteTitle">VOTA</div>
            <div class="voteTime mono" id="voteTime">00:20</div>
          </div>
          <div class="voteHint" id="voteHint">Votaci√≥n en‚Ä¶</div>
          <div class="voteBars">
            <div class="voteBar">
              <div class="voteBarFill" id="voteYes"></div>
              <div class="voteBarLabel"><span>NEXT</span><span id="voteYesN">0</span></div>
            </div>
            <div class="voteBar">
              <div class="voteBarFill no" id="voteNo"></div>
              <div class="voteBarLabel"><span>STAY</span><span id="voteNoN">0</span></div>
            </div>
          </div>
        </div>

        <!-- Chat -->
        <div id="rlcChatRoot" class="rlcChatRoot" aria-label="Chat overlay" aria-live="polite">
          <div id="rlcChatList"></div>
        </div>
      </div>

      <audio id="bgm" preload="auto" crossorigin="anonymous"></audio>
    </section>

    <noscript>
      <section class="fallback" style="position:fixed; inset:0; z-index:9999">
        <div class="fallbackCard">
          <div class="fallbackTitle">JavaScript desactivado</div>
          <div class="fallbackText">Este reproductor necesita JavaScript para rotar c√°maras y mostrar overlays.</div>
        </div>
      </section>
    </noscript>
  </main>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TICKER ROOTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div id="rlcNewsTicker" aria-label="News ticker" aria-live="polite"></div>
  <div id="rlcEconTicker" aria-label="Econ ticker" aria-live="polite"></div>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DIAGN√ìSTICO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div id="rlcDiag" aria-live="polite">
    <div class="card">
      <div class="hdr">Diagn√≥stico (PLAYER)</div>
      <pre id="rlcDiagText"></pre>
      <div class="tip">Tip: prueba <b>index.html?repair=1</b> para limpiar cach√©s y reset total.</div>
    </div>
  </div>

  <!-- Captura errores JS y los muestra en pantalla (PLAYER) -->
  <script>
    (() => {
      "use strict";
      const qs = (s) => document.querySelector(s);

      const showDiag = (msg) => {
        const box = qs("#rlcDiag");
        const pre = qs("#rlcDiagText");
        if (pre) pre.textContent = String(msg || "");
        if (box) box.classList.add("on");
      };

      window.addEventListener("error", (e) => {
        try {
          const lines = [
            `[${new Date().toISOString()}] window.error`,
            `message: ${String(e.message || "")}`,
            `file: ${String(e.filename || "")}:${String(e.lineno || "")}:${String(e.colno || "")}`,
            `stack: ${e.error && e.error.stack ? e.error.stack : "(no stack)"}`
          ];
          showDiag(lines.join("\n"));
        } catch (_) {}
      });

      window.addEventListener("unhandledrejection", (e) => {
        try {
          const r = e.reason;
          const text = (r && (r.stack || r.message)) ? (r.stack || r.message) : String(r);
          showDiag(`[${new Date().toISOString()}] unhandledrejection\n${text}`);
        } catch (_) {}
      });
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHAT VISIBILITY BOOT (v2.3.9) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       - Activa chat si URL trae ?chat=1 / true / on / yes
       - Si llegan mensajes a #rlcChatList, fuerza chat visible (sin depender de clases del renderer) -->
  <script>
    (() => {
      "use strict";
      const safeStr = (v) => (typeof v === "string") ? v.trim() : "";
      const root = document.getElementById("rlcChatRoot");
      const list = document.getElementById("rlcChatList");
      if (!root || !list) return;

      const u = new URL(location.href);
      const raw =
        safeStr(u.searchParams.get("chat") || "") ||
        safeStr(u.searchParams.get("chatOverlay") || "") ||
        safeStr(u.searchParams.get("chatOn") || "") ||
        safeStr(u.searchParams.get("c") || "");

      const v = String(raw || "").toLowerCase();
      const wantsOn  = (v === "1" || v === "true" || v === "on" || v === "yes");
      const wantsOff = (v === "0" || v === "false" || v === "off" || v === "no");

      const setOn = () => {
        root.classList.add("chat--on");
        document.body.classList.add("chat--on");
        try { document.body.setAttribute("data-chat", "1"); } catch (_) {}
      };
      const setOff = () => {
        root.classList.remove("chat--on");
        document.body.classList.remove("chat--on");
        try { document.body.removeAttribute("data-chat"); } catch (_) {}
      };

      if (wantsOn) setOn();
      if (wantsOff) setOff();

      // Si entra cualquier mensaje, muestra chat
      try {
        const obs = new MutationObserver((muts) => {
          for (const m of muts) {
            if (m && m.type === "childList" && m.addedNodes && m.addedNodes.length) {
              setOn();
              break;
            }
          }
        });
        obs.observe(list, { childList: true, subtree: true });
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SW REGISTER (PLAYER) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚úÖ GitHub Pages friendly
       ‚úÖ updateViaCache:"none"
       ‚úÖ Re-registra por versi√≥n (sw.js?v=APP_VERSION)
       ‚ùå Se salta si ?repair=1 o ?nosw=1 -->
  <script>
    (() => {
      "use strict";
      const g = (typeof globalThis !== "undefined") ? globalThis : window;
      const GUARD = "__RLC_SW_BOOT_V1";
      try { if (g[GUARD]) return; g[GUARD] = true; } catch (_) {}

      try {
        const u = new URL(location.href);
        if (u.searchParams.has("repair")) return;
        const nosw = String(u.searchParams.get("nosw") || "").toLowerCase();
        if (nosw === "1" || nosw === "true" || nosw === "on") return;

        if (!("serviceWorker" in navigator)) return;

        const V = String(window.APP_VERSION || "").trim() || "0";
        const swUrl = `./sw.js?v=${encodeURIComponent(V)}`;

        let reloaded = false;

        navigator.serviceWorker.register(swUrl, { updateViaCache: "none" })
          .then((reg) => {
            try { reg && reg.update && reg.update(); } catch (_) {}

            // update peri√≥dico suave (por si GH Pages cachea raro)
            try {
              setInterval(() => { try { reg.update && reg.update(); } catch (_) {} }, 60_000);
            } catch (_) {}
          })
          .catch(() => {});

        navigator.serviceWorker.addEventListener("controllerchange", () => {
          if (reloaded) return;
          reloaded = true;
          try { location.reload(); } catch (_) {}
        });
      } catch (_) {}
    })();
  </script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATA + MODULES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <script defer src="./cams.js?v=2.3.9"></script>
  <script defer src="./music.js?v=2.3.9"></script>
  <script defer src="./weatherClock.js?v=2.3.9"></script>
  <script defer src="./rlcTickers.js?v=2.3.9"></script>
  <script defer src="./catalogView.js?v=2.3.9"></script>
  <script defer src="./pointsControl.js?v=2.3.9"></script>
  <script defer src="./app.js?v=2.3.9"></script>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTDOWN BOOTSTRAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       Permite cfg desde control v√≠a BC/LS + par√°metros URL.
       ‚úÖ Compat legacy: acepta mensajes sin key en legacy bus.
       ‚úÖ FIX: sin bitwise "|0" (evita overflow en countdowns largos). -->
  <script>
    (() => {
      "use strict";

      const g = (typeof globalThis !== "undefined") ? globalThis : window;
      const LOAD_GUARD = "__RLC_COUNTDOWN_BOOT_V110";
      try { if (g[LOAD_GUARD]) return; g[LOAD_GUARD] = true; } catch (_) {}

      const BUS_BASE = "rlc_bus_v1";
      const CD_KEY_BASE = "rlc_countdown_cfg_v1";
      const LAST_KEY_STORE = "rlc_last_key_v1";

      const qs = (s, r = document) => r.querySelector(s);
      const safeStr = (v) => (typeof v === "string") ? v.trim() : "";

      function parseParams() {
        const u = new URL(location.href);
        const countdown = safeStr(u.searchParams.get("countdown") || "");

        const keyFromUrl = safeStr(u.searchParams.get("key") || "");
        const keyFromStore = (() => { try { return safeStr(localStorage.getItem(LAST_KEY_STORE) || ""); } catch (_) { return ""; } })();
        const key = keyFromUrl || keyFromStore;

        const toA = safeStr(u.searchParams.get("countdownTo") || "");
        const toB = safeStr(u.searchParams.get("countTo") || "");
        const toC = safeStr(u.searchParams.get("countdownTarget") || "");

        const labelA = safeStr(u.searchParams.get("countdownLabel") || "");
        const labelB = safeStr(u.searchParams.get("countLabel") || "");

        const posA = safeStr(u.searchParams.get("countdownPos") || "");
        const posB = safeStr(u.searchParams.get("countPos") || "");

        return {
          key,
          countdown,
          countdownTo: toC || toA || toB,
          countdownLabel: labelA || labelB,
          countdownPos: posA || posB
        };
      }

      const P = parseParams();
      const KEY = P.key;

      const BUS = KEY ? `${BUS_BASE}:${KEY}` : BUS_BASE;
      const BUS_LEGACY = BUS_BASE;

      const CD_KEY = KEY ? `${CD_KEY_BASE}:${KEY}` : CD_KEY_BASE;
      const CD_KEY_LEGACY = CD_KEY_BASE;

      const bcMain = ("BroadcastChannel" in window) ? new BroadcastChannel(BUS) : null;
      const bcLegacy = (("BroadcastChannel" in window) && KEY) ? new BroadcastChannel(BUS_LEGACY) : null;

      // ‚úÖ Compat legacy: si viene sin key, aceptamos.
      function keyOk(msg, isMain) {
        if (!KEY) return true;
        if (isMain) return true; // el canal principal ya est√° namespaced por KEY
        const mk = safeStr(msg && msg.key || "");
        if (!mk) return true;    // legacy control viejo
        return mk === KEY;
      }

      const DEFAULTS = {
        enabled: false,
        label: "FIN DE A√ëO",
        targetMs: 0,
        targetIso: "",
        position: "tr",
        hideHudWhenCatalog: true
      };

      function readJson(key) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          return (obj && typeof obj === "object") ? obj : null;
        } catch (_) { return null; }
      }

      function normalizeCfg(inCfg) {
        const c = Object.assign({}, DEFAULTS, inCfg || {});
        c.enabled = (c.enabled === true);

        c.label = safeStr(c.label || DEFAULTS.label).slice(0, 60) || DEFAULTS.label;
        c.position = (c.position === "tl" || c.position === "tr" || c.position === "bl" || c.position === "br") ? c.position : "tr";
        c.hideHudWhenCatalog = (c.hideHudWhenCatalog !== false);

        const ms = (typeof c.targetMs === "number") ? c.targetMs : parseInt(String(c.targetMs || "0"), 10);
        c.targetMs = Number.isFinite(ms) ? Math.max(0, ms) : 0;
        c.targetIso = safeStr(c.targetIso || "");

        // Permite timestamp en targetIso (10 o 13 d√≠gitos)
        if (!c.targetMs && /^\d{10,13}$/.test(c.targetIso)) {
          const n = parseInt(c.targetIso, 10);
          if (Number.isFinite(n)) c.targetMs = (String(n).length === 10) ? (n * 1000) : n;
          c.targetIso = "";
        }

        return c;
      }

      function cfgFromUrlParams() {
        const on = (P.countdown === "1" || P.countdown === "true");
        if (!on && !P.countdownTo && !P.countdownLabel) return null;

        let targetMs = 0;
        const rawTo = safeStr(P.countdownTo || "");

        if (rawTo) {
          if (/^\d{10,13}$/.test(rawTo)) {
            const n = parseInt(rawTo, 10);
            if (Number.isFinite(n)) targetMs = (String(n).length === 10) ? (n * 1000) : n;
          } else {
            const d = new Date(rawTo);
            const ms = d.getTime();
            if (Number.isFinite(ms) && ms > 0) targetMs = ms;
          }
        }

        return normalizeCfg({
          enabled: on || !!targetMs,
          label: P.countdownLabel || DEFAULTS.label,
          targetMs,
          position: P.countdownPos || "tr"
        });
      }

      function loadCfg() {
        const stored = readJson(CD_KEY) || readJson(CD_KEY_LEGACY);
        const urlCfg = cfgFromUrlParams();
        return normalizeCfg(stored || urlCfg || DEFAULTS);
      }

      let CFG = loadCfg();

      const root = qs("#rlcCountdown");
      const elLbl = qs("#rlcCountdownLabel");
      const elTime = qs("#rlcCountdownTime");
      const hud = qs("#hud");

      let targetMs = 0;

      function setPos(pos) {
        if (!root) return;
        root.classList.remove("tr", "tl", "br", "bl");
        root.classList.add(pos || "tr");
      }

      function show(on) {
        if (!root) return;
        root.classList.toggle("hidden", !on);
      }

      function nextNewYearLocalMs() {
        try {
          const now = new Date();
          const y = now.getFullYear() + 1;
          return new Date(y, 0, 1, 0, 0, 0, 0).getTime();
        } catch (_) { return 0; }
      }

      function applyCfg(cfg) {
        CFG = normalizeCfg(cfg);

        if (elLbl) elLbl.textContent = CFG.label || DEFAULTS.label;
        setPos(CFG.position || "tr");

        targetMs = CFG.targetMs || 0;
        if (!targetMs && CFG.targetIso) {
          const d = new Date(CFG.targetIso);
          const ms = d.getTime();
          if (Number.isFinite(ms) && ms > 0) targetMs = ms;
        }
        if (!targetMs && CFG.enabled) targetMs = nextNewYearLocalMs();

        show(!!(CFG.enabled && targetMs > 0));
      }

      // ‚úÖ FIX: nada de bitwise (evita overflow > 24 d√≠as aprox)
      function fmtRemain(ms) {
        ms = Math.max(0, Math.floor(ms));
        const sec = Math.floor(ms / 1000);

        const d = Math.floor(sec / 86400);
        const h = Math.floor((sec % 86400) / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = Math.floor(sec % 60);

        const pad = (n) => String(n).padStart(2, "0");
        if (d > 0) return `${d}d ${pad(h)}:${pad(m)}:${pad(s)}`;
        return `${pad(h)}:${pad(m)}:${pad(s)}`;
      }

      function isCatalogOn() {
        const c = qs("#rlcCatalog");
        return !!(c && c.classList.contains("on"));
      }

      function tick() {
        try {
          if (hud && CFG.hideHudWhenCatalog) {
            hud.style.display = isCatalogOn() ? "none" : "";
          }
        } catch (_) {}

        if (!root || root.classList.contains("hidden")) return;
        if (!targetMs) return;

        const ms = targetMs - Date.now();
        if (ms <= 0) {
          if (elTime) elTime.textContent = "üéâ 00:00:00";
          if (elLbl) elLbl.textContent = "FELIZ A√ëO NUEVO";
          return;
        }

        if (elTime) elTime.textContent = fmtRemain(ms);
      }

      function onBusMessage(msg, isMain) {
        if (!msg || typeof msg !== "object") return;

        if (msg.type === "COUNTDOWN_CFG" && msg.cfg && typeof msg.cfg === "object") {
          if (!keyOk(msg, isMain)) return;
          applyCfg(msg.cfg);
          return;
        }

        if (msg.type === "cmd" && (msg.cmd === "COUNTDOWN_SET" || msg.name === "COUNTDOWN_SET") && msg.payload && typeof msg.payload === "object") {
          if (!keyOk(msg, isMain)) return;
          applyCfg(msg.payload);
          return;
        }
      }

      if (bcMain) bcMain.addEventListener("message", (ev) => onBusMessage(ev?.data, true));
      if (bcLegacy) bcLegacy.addEventListener("message", (ev) => onBusMessage(ev?.data, false));

      window.addEventListener("storage", (e) => {
        if (!e || !e.key) return;
        if (e.key === CD_KEY || e.key === CD_KEY_LEGACY) applyCfg(loadCfg());
      });

      function boot() {
        applyCfg(loadCfg());
        tick();
        setInterval(tick, 250);
      }

      if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", boot, { once: true });
      else boot();
    })();
  </script>
</body>
</html>

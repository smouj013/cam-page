<!doctype html>
<html lang="es" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0b0f14" />
  <meta name="robots" content="noindex,nofollow" />
  <title>Twitch OAuth Return</title>

  <style>
    :root{
      --bg0:#05060b; --bg1:#070b14; --bg2:#0a1528;
      --panel: rgba(10,14,22,.78);
      --stroke: rgba(255,255,255,.12);
      --stroke2: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.66);
      --ok:#19e28a; --bad:#ff5a5a; --acc:#37d6ff;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    body{
      margin:0; min-height:100svh; color:var(--text); font-family:var(--sans);
      background:
        radial-gradient(1200px 900px at 20% 0%, rgba(55,214,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(255,59,59,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 35%, var(--bg2));
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed; inset:0; pointer-events:none; z-index:0; opacity:.65;
      background:
        radial-gradient(900px 700px at 50% 40%, rgba(0,0,0,.20), rgba(0,0,0,.72)),
        repeating-linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, rgba(255,255,255,0) 1px 3px),
        linear-gradient(90deg, rgba(55,214,255,.08), transparent 35%, rgba(255,59,59,.07));
      mix-blend-mode: screen;
    }
    .wrap{position:relative; z-index:1; padding:24px;}
    .card{
      max-width: 1120px; margin: 0 auto;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar{
      padding: 16px 18px;
      background: linear-gradient(90deg, rgba(255,59,59,.18), rgba(10,14,22,.88) 25%, rgba(55,214,255,.16));
      border-bottom: 1px solid var(--stroke);
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .title{display:flex; flex-direction:column; gap:4px;}
    .kicker{letter-spacing:.26em; font-weight:900; font-size:12px; opacity:.82}
    h1{margin:0; font-size:16px; letter-spacing:.04em; text-transform:uppercase}
    .pill{
      font: 900 12px/1 var(--sans);
      border: 1px solid var(--stroke2);
      background: rgba(0,0,0,.25);
      padding: 8px 10px;
      border-radius: 999px;
      display:inline-flex; align-items:center; gap:8px;
      user-select:none;
      white-space:nowrap;
    }
    .pill.ok{border-color: rgba(25,226,138,.35);}
    .pill.bad{border-color: rgba(255,90,90,.40);}
    .body{padding: 18px;}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (min-width: 980px){
      .grid{grid-template-columns: 1.35fr .65fr;}
    }
    .box{
      border: 1px solid var(--stroke);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      padding: 12px;
      overflow:auto;
    }
    pre{
      margin:0; font-family: var(--mono);
      white-space: pre-wrap; word-break: break-word;
      color: rgba(255,255,255,.92);
    }
    code{font-family:var(--mono)}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px;}
    .btn{
      cursor:pointer; border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      color: rgba(255,255,255,.92);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing:.02em;
      box-shadow: 0 10px 30px rgba(0,0,0,.30);
      transition: transform .12s ease, border-color .12s ease, filter .12s ease;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(55,214,255,.25); filter: brightness(1.05);}
    .btn.ghost{background: rgba(0,0,0,.18);}
    .btn.full{flex:1 1 220px;}
    .warn{
      margin-top: 12px;
      border-left: 3px solid rgba(255,90,90,.65);
      padding: 10px 12px;
      background: rgba(255,90,90,.08);
      border-radius: 12px;
    }
    .good{
      margin-top: 12px;
      border-left: 3px solid rgba(25,226,138,.55);
      padding: 10px 12px;
      background: rgba(25,226,138,.08);
      border-radius: 12px;
    }
    .field{display:flex; flex-direction:column; gap:6px; margin-top: 10px;}
    label{font-weight:950; letter-spacing:.02em; font-size:12px; opacity:.9}
    input, textarea, select{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      outline:none;
      font-family: var(--mono);
    }
    textarea{min-height:110px; resize:vertical}
    .kv{
      display:grid;
      grid-template-columns: 160px 1fr;
      gap:8px 10px;
      align-items:center;
    }
    .k{color: rgba(255,255,255,.78); font-weight:900; font-size:12px; letter-spacing:.02em}
    .v{font-family: var(--mono); color: rgba(255,255,255,.92)}
    .chipRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    .chip{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      padding: 8px 10px;
      border-radius: 999px;
      cursor:pointer;
      font: 900 12px/1 var(--sans);
      user-select:none;
      transition: border-color .12s ease, transform .12s ease, filter .12s ease;
    }
    .chip:hover{transform: translateY(-1px); border-color: rgba(55,214,255,.25); filter: brightness(1.05);}
    .chip.on{border-color: rgba(25,226,138,.35);}
    .hr{height:1px; background: rgba(255,255,255,.10); margin:14px 0;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="title">
          <div class="kicker" id="kicker">OAUTH CALLBACK</div>
          <h1 id="headline">Twitch OAuth</h1>
        </div>
        <div id="pill" class="pill">Leyendo respuesta…</div>
      </div>

      <div class="body">
        <p class="muted small" style="margin:0">
          Esta página sirve para:
          <b>(1)</b> generar el link de login,
          <b>(2)</b> capturar el <code>access_token</code> devuelto (en <code>#</code>),
          <b>(3)</b> validarlo vía <code>/oauth2/validate</code>,
          <b>(4)</b> darte <b>todos los valores listos</b> para Helix/IRC y para tu panel (<code>.env</code>/<code>JSON</code>).
        </p>

        <div class="grid">
          <!-- IZQ: RESULTADO -->
          <div>
            <div class="field">
              <label>Redirect URI (este mismo)</label>
              <input id="redirectBox" type="text" readonly />
              <div class="muted small">Añade esta URL EXACTA en tu app de Twitch → <b>OAuth Redirect URLs</b>.</div>
            </div>

            <div class="row">
              <button id="copyRedirectBtn" class="btn ghost full" type="button">Copiar redirect URI</button>
              <button id="closeBtn" class="btn ghost full" type="button">Cerrar</button>
            </div>

            <div id="msgBox" class=""></div>

            <div class="hr"></div>

            <div class="field">
              <label>Access Token (Helix)</label>
              <div class="box"><pre id="tokenBox">(vacío)</pre></div>
              <div class="muted small">
                Helix usa: <code>Authorization: Bearer &lt;token&gt;</code> + <code>Client-Id: &lt;client_id&gt;</code>
              </div>
            </div>

            <div class="field">
              <label>IRC PASS (para bot)</label>
              <div class="box"><pre id="ircPassBox">(vacío)</pre></div>
              <div class="muted small">IRC usa <code>PASS oauth:&lt;token&gt;</code> (prefijo <code>oauth:</code>).</div>
            </div>

            <div class="field">
              <label>Scopes (permisos)</label>
              <div class="box"><pre id="scopeBox">(vacío)</pre></div>
            </div>

            <div class="row">
              <button id="copyTokenBtn" class="btn full" type="button">Copiar token</button>
              <button id="copyIrcBtn" class="btn ghost full" type="button">Copiar IRC PASS</button>
              <button id="copyScopesBtn" class="btn ghost full" type="button">Copiar scopes</button>
            </div>

            <div class="field" style="margin-top:14px">
              <label>Datos (validate)</label>
              <div class="box">
                <div class="kv">
                  <div class="k">User ID (canal)</div><div class="v" id="broadcasterId">(—)</div>
                  <div class="k">Login (usuario)</div><div class="v" id="loginName">(—)</div>
                  <div class="k">Client ID (app)</div><div class="v" id="clientIdOut">(—)</div>
                  <div class="k">Expira en</div><div class="v" id="expiresOut">(—)</div>
                  <div class="k">State</div><div class="v" id="stateOut">(—)</div>
                </div>
              </div>
            </div>

            <div class="row">
              <button id="copyBroadcasterBtn" class="btn full" type="button">Copiar User ID</button>
              <button id="copyLoginBtn" class="btn ghost full" type="button">Copiar login</button>
              <button id="copyClientIdBtn" class="btn ghost full" type="button">Copiar Client ID</button>
            </div>

            <div class="field" style="margin-top:14px">
              <label>Bloque “pegar en tu panel” (.env)</label>
              <div class="box"><pre id="envBox">(vacío)</pre></div>
            </div>

            <div class="row">
              <button id="copyEnvBtn" class="btn full" type="button">Copiar .env</button>
              <button id="copyJsonBtn" class="btn ghost full" type="button">Copiar JSON</button>
            </div>

            <div class="warn small">
              ⚠️ No publiques este token. Trátalo como contraseña. Guárdalo solo en local (tu panel admin / localStorage).
            </div>
          </div>

          <!-- DER: GENERADOR -->
          <div>
            <div class="field">
              <label>Modo / presets</label>
              <div class="muted small">Elige un preset y te rellena scopes recomendados.</div>
              <div class="chipRow" id="presetRow">
                <div class="chip" data-preset="bot">BOT (chat)</div>
                <div class="chip" data-preset="title">TÍTULO/CATEGORÍA</div>
                <div class="chip" data-preset="ads">ADS / COMMERCIAL</div>
                <div class="chip" data-preset="custom">CUSTOM</div>
              </div>
            </div>

            <div class="field">
              <label>Client ID (de tu app de Twitch)</label>
              <input id="clientId" type="text" placeholder="Pega tu Client ID aquí" autocomplete="off"/>
              <div class="muted small">Esto es el ID de la app (Developer Console). No es tu user_id.</div>
            </div>

            <div class="field">
              <label>Scopes (separados por espacio)</label>
              <input id="scopes" type="text" value="chat:read chat:edit" autocomplete="off"/>
              <div class="muted small">
                IRC: <code>chat:read chat:edit</code>. Título: <code>channel:manage:broadcast</code>.
              </div>
            </div>

            <div class="field">
              <label>Opciones</label>
              <div class="box">
                <div class="small muted" style="line-height:1.45">
                  <div><b>target</b>: etiqueta para tu panel (bot/title/ads/custom)</div>
                  <div><b>autoclose</b>: si viene en <code>?autoclose=1</code> cierra tras capturar</div>
                  <div><b>persist</b>: si viene <code>?persist=1</code> recuerda Client ID y preset en este navegador</div>
                </div>
              </div>
            </div>

            <div class="row">
              <button id="openAuthBtn" class="btn full" type="button">Abrir login Twitch</button>
              <button id="copyAuthBtn" class="btn ghost full" type="button">Copiar URL login</button>
            </div>

            <div class="field">
              <label>URL de login generada</label>
              <div class="box"><pre id="authUrlBox">(vacío)</pre></div>
            </div>

            <div class="good small">
              Si sale <b>redirect_mismatch</b>:
              <ul style="margin:8px 0 0; padding-left:18px">
                <li>El <code>redirect_uri</code> del login debe ser EXACTAMENTE <code id="redirMini"></code></li>
                <li>Añádelo tal cual en la app → <b>OAuth Redirect URLs</b>.</li>
              </ul>
            </div>

            <div class="muted small" style="margin-top:10px">
              Si abriste esto desde <code>control.html</code> en popup, al llegar el token
              se enviará por <code>postMessage</code> al panel automáticamente.
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  // ─────────────────────────────────────────────────────────────
  // Twitch OAuth Helper (Implicit Flow) + Validate + Export
  // ─────────────────────────────────────────────────────────────
  const pill = document.getElementById("pill");
  const msgBox = document.getElementById("msgBox");

  const tokenBox = document.getElementById("tokenBox");
  const ircPassBox = document.getElementById("ircPassBox");
  const scopeBox = document.getElementById("scopeBox");

  const closeBtn = document.getElementById("closeBtn");
  const copyTokenBtn = document.getElementById("copyTokenBtn");
  const copyIrcBtn = document.getElementById("copyIrcBtn");
  const copyScopesBtn = document.getElementById("copyScopesBtn");

  const redirectBox = document.getElementById("redirectBox");
  const redirMini = document.getElementById("redirMini");
  const copyRedirectBtn = document.getElementById("copyRedirectBtn");

  const clientIdEl = document.getElementById("clientId");
  const scopesEl = document.getElementById("scopes");
  const openAuthBtn = document.getElementById("openAuthBtn");
  const copyAuthBtn = document.getElementById("copyAuthBtn");
  const authUrlBox = document.getElementById("authUrlBox");

  const broadcasterIdEl = document.getElementById("broadcasterId");
  const loginNameEl = document.getElementById("loginName");
  const clientIdOutEl = document.getElementById("clientIdOut");
  const expiresOutEl = document.getElementById("expiresOut");
  const stateOutEl = document.getElementById("stateOut");

  const copyBroadcasterBtn = document.getElementById("copyBroadcasterBtn");
  const copyLoginBtn = document.getElementById("copyLoginBtn");
  const copyClientIdBtn = document.getElementById("copyClientIdBtn");

  const envBox = document.getElementById("envBox");
  const copyEnvBtn = document.getElementById("copyEnvBtn");
  const copyJsonBtn = document.getElementById("copyJsonBtn");

  const presetRow = document.getElementById("presetRow");
  const kickerEl = document.getElementById("kicker");
  const headlineEl = document.getElementById("headline");

  const okPill = (t) => { pill.className = "pill ok"; pill.textContent = t; };
  const badPill = (t) => { pill.className = "pill bad"; pill.textContent = t; };

  const showWarn = (html) => { msgBox.className = "warn small"; msgBox.innerHTML = html; };
  const showGood = (html) => { msgBox.className = "good small"; msgBox.innerHTML = html; };
  const clearMsg = () => { msgBox.className = ""; msgBox.innerHTML = ""; };

  const qp = new URLSearchParams(location.search);

  // target: etiqueta para tu panel (bot/title/ads/custom)
  const target = (qp.get("target") || qp.get("for") || "custom").toLowerCase();

  // Prefill opcional
  const preScopes = (qp.get("scopes") || "").trim();
  const preClientId = (qp.get("client_id") || "").trim();

  // Autoclose: cierra el popup al capturar token
  const autoClose = (qp.get("autoclose") === "1");

  // Persist: recuerda ClientID/preset en local
  const persist = (qp.get("persist") === "1");
  const LS_KEY = "rlc_oauth_helper_v1";

  function safeDecode(s) {
    try { return decodeURIComponent(String(s || "")); }
    catch { return String(s || ""); }
  }
  function decodeScopesLikeTwitch(s){
    // Twitch puede devolver scope en fragmento con + o %20
    const raw = String(s || "");
    return safeDecode(raw.replace(/\+/g, " ")).trim();
  }

  function cleanRedirectUri() {
    // redirect_uri estable: sin query, sin hash
    return location.origin + location.pathname;
  }

  redirectBox.value = cleanRedirectUri();
  redirMini.textContent = cleanRedirectUri();

  // ───────────── Presets (puedes ampliarlos sin romper nada) ─────────────
  const PRESETS = {
    bot:   { label:"OAUTH (BOT)",   title:"✅ OAuth del BOT",   scopes:"chat:read chat:edit" },
    title: { label:"OAUTH (TITLE)", title:"✅ OAuth (título)",  scopes:"channel:manage:broadcast" },
    ads:   { label:"OAUTH (ADS)",   title:"✅ OAuth (ads)",     scopes:"channel:edit:commercial channel:manage:ads" },
    custom:{ label:"OAUTH (CUSTOM)",title:"✅ OAuth (custom)",  scopes:"" }
  };

  function setActivePreset(p){
    const preset = PRESETS[p] ? p : "custom";
    [...presetRow.querySelectorAll(".chip")].forEach(ch => {
      ch.classList.toggle("on", (ch.dataset.preset === preset));
    });
    const info = PRESETS[preset];
    kickerEl.textContent = info.label;
    headlineEl.textContent = info.title;

    if (!preScopes) {
      if (preset === "custom") {
        // no pisar si ya escribió
        if (!scopesEl.value.trim()) scopesEl.value = "chat:read chat:edit";
      } else {
        scopesEl.value = info.scopes;
      }
    }

    // guardar preset si persist=1
    if (persist) {
      try {
        const data = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
        data.preset = preset;
        localStorage.setItem(LS_KEY, JSON.stringify(data));
      } catch (_) {}
    }
  }

  presetRow.addEventListener("click", (e) => {
    const chip = e.target && e.target.closest ? e.target.closest(".chip") : null;
    if (!chip) return;
    setActivePreset(chip.dataset.preset || "custom");
  });

  // Restore persist
  if (persist) {
    try {
      const data = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
      if (!preClientId && data.client_id) clientIdEl.value = String(data.client_id);
      if (!preScopes && data.scopes) scopesEl.value = String(data.scopes);
      if (data.preset) setActivePreset(String(data.preset));
    } catch (_) {}
  }

  // Default preset por target
  if (target === "bot") setActivePreset("bot");
  else if (target === "title") setActivePreset("title");
  else if (target === "ads") setActivePreset("ads");
  else setActivePreset("custom");

  // Pre-fill from query
  if (preClientId) clientIdEl.value = preClientId;
  if (preScopes) scopesEl.value = preScopes;

  function randState(){
    try { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random()).slice(2); }
    catch { return String(Math.random()).slice(2); }
  }

  async function copyText(text) {
    const t = String(text || "").trim();
    if (!t) return false;
    try { await navigator.clipboard.writeText(t); return true; }
    catch (_) {
      try {
        const ta = document.createElement("textarea");
        ta.value = t;
        ta.style.position = "fixed";
        ta.style.opacity = "0";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        return true;
      } catch { return false; }
    }
  }

  function buildAuthorizeUrl(clientId, scopes) {
    const cid = String(clientId || "").trim();
    const sc = String(scopes || "").trim();
    const redirect = cleanRedirectUri();
    const st = randState();

    try { sessionStorage.setItem("twitch_oauth_state", st); } catch (_) {}

    // Implicit flow (token en #)
    const u = new URL("https://id.twitch.tv/oauth2/authorize");
    u.searchParams.set("response_type", "token");
    u.searchParams.set("client_id", cid);
    u.searchParams.set("redirect_uri", redirect);
    if (sc) u.searchParams.set("scope", sc);
    u.searchParams.set("state", st);
    u.searchParams.set("force_verify", "true");

    // añadimos nuestro target para que el callback lo sepa incluso si viene “limpio”
    u.searchParams.set("target", target);

    return u.toString();
  }

  function clearTokenFromAddressBar() {
    // quita el fragmento con el token de la barra (seguridad)
    try { history.replaceState(null, "", location.pathname + location.search); } catch (_) {}
  }

  function setValidatedInfo({ user_id = "", login = "", client_id = "", scopes = [], expires_in = 0 } = {}) {
    broadcasterIdEl.textContent = user_id ? String(user_id) : "(—)";
    loginNameEl.textContent = login ? String(login) : "(—)";
    clientIdOutEl.textContent = client_id ? String(client_id) : "(—)";

    if (expires_in && Number.isFinite(expires_in)) {
      const mins = Math.max(0, Math.round(expires_in / 60));
      expiresOutEl.textContent = `${mins} min`;
    } else {
      expiresOutEl.textContent = "(—)";
    }

    if (Array.isArray(scopes) && scopes.length) {
      scopeBox.textContent = scopes.join(" ");
    }
  }

  async function validateToken(token) {
    const t = String(token || "").trim();
    if (!t) throw new Error("token vacío");

    const tryFetch = async (authValue) => {
      const r = await fetch("https://id.twitch.tv/oauth2/validate", {
        method: "GET",
        headers: { "Authorization": authValue }
      });
      if (!r.ok) {
        const txt = await r.text().catch(() => "");
        const e = new Error(`validate HTTP ${r.status}${txt ? ` — ${txt.slice(0, 180)}` : ""}`);
        e.status = r.status;
        throw e;
      }
      return await r.json();
    };

    // Twitch acepta OAuth o Bearer
    try { return await tryFetch(`OAuth ${t}`); }
    catch (_) { return await tryFetch(`Bearer ${t}`); }
  }

  function buildEnvBlock({
    access_token="", token_type="bearer", scopes="", client_id="", user_id="", login="", expires_in=0, target=""
  }){
    const sc = String(scopes || "").trim();
    const irc = access_token ? `oauth:${access_token}` : "";
    return [
      `# Twitch OAuth export (${target || "custom"})`,
      `TWITCH_TARGET=${target || ""}`,
      `TWITCH_CLIENT_ID=${client_id || ""}`,
      `TWITCH_LOGIN=${login || ""}`,
      `TWITCH_USER_ID=${user_id || ""}`,
      `TWITCH_ACCESS_TOKEN=${access_token || ""}`,
      `TWITCH_TOKEN_TYPE=${token_type || "bearer"}`,
      `TWITCH_SCOPES=${sc}`,
      `TWITCH_EXPIRES_IN=${Number(expires_in || 0)}`,
      `TWITCH_IRC_PASS=${irc}`,
      ``,
      `# Helix headers:`,
      `# Authorization: Bearer ${access_token || "<token>"}`,
      `# Client-Id: ${client_id || "<client_id>"}`
    ].join("\n");
  }

  function buildJsonExport(o){
    try { return JSON.stringify(o, null, 2); } catch { return "{}"; }
  }

  // UI handlers
  copyRedirectBtn.addEventListener("click", async () => {
    const ok = await copyText(redirectBox.value);
    if (ok) showGood("✅ Redirect URI copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyTokenBtn.addEventListener("click", async () => {
    const ok = await copyText(tokenBox.textContent);
    if (ok) showGood("✅ Token copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyIrcBtn.addEventListener("click", async () => {
    const ok = await copyText(ircPassBox.textContent);
    if (ok) showGood("✅ IRC PASS copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyScopesBtn.addEventListener("click", async () => {
    const ok = await copyText(scopeBox.textContent);
    if (ok) showGood("✅ Scopes copiados.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyBroadcasterBtn.addEventListener("click", async () => {
    const ok = await copyText(broadcasterIdEl.textContent);
    if (ok) showGood("✅ User ID copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyLoginBtn.addEventListener("click", async () => {
    const ok = await copyText(loginNameEl.textContent);
    if (ok) showGood("✅ Login copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyClientIdBtn.addEventListener("click", async () => {
    const ok = await copyText(clientIdOutEl.textContent);
    if (ok) showGood("✅ Client ID copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyEnvBtn.addEventListener("click", async () => {
    const ok = await copyText(envBox.textContent);
    if (ok) showGood("✅ .env copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  copyJsonBtn.addEventListener("click", async () => {
    const obj = window.__RLC_OAUTH_EXPORT__ || null;
    const ok = await copyText(buildJsonExport(obj || {}));
    if (ok) showGood("✅ JSON copiado.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  closeBtn.addEventListener("click", () => { try { window.close(); } catch (_) {} });

  function refreshAuthUrlBox(){
    const cid = clientIdEl.value.trim();
    const url = cid ? buildAuthorizeUrl(cid, scopesEl.value) : "";
    authUrlBox.textContent = url || "(vacío)";
    return url;
  }

  clientIdEl.addEventListener("input", () => {
    if (persist) {
      try {
        const data = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
        data.client_id = clientIdEl.value.trim();
        localStorage.setItem(LS_KEY, JSON.stringify(data));
      } catch (_) {}
    }
    refreshAuthUrlBox();
  });

  scopesEl.addEventListener("input", () => {
    if (persist) {
      try {
        const data = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
        data.scopes = scopesEl.value.trim();
        localStorage.setItem(LS_KEY, JSON.stringify(data));
      } catch (_) {}
    }
    refreshAuthUrlBox();
  });

  openAuthBtn.addEventListener("click", () => {
    clearMsg();
    const cid = clientIdEl.value.trim();
    if (!cid) { showWarn("Pon tu <b>Client ID</b> primero."); return; }
    const url = refreshAuthUrlBox();
    location.href = url;
  });

  copyAuthBtn.addEventListener("click", async () => {
    clearMsg();
    const cid = clientIdEl.value.trim();
    if (!cid) { showWarn("Pon tu <b>Client ID</b> primero."); return; }
    const url = refreshAuthUrlBox();
    const ok = await copyText(url);
    if (ok) showGood("✅ URL de login copiada.");
    else showWarn("❌ No se pudo copiar. Copia manualmente.");
  });

  // ───────────── Captura de fragment (#access_token=...) ─────────────
  const hash = (location.hash || "").startsWith("#") ? location.hash.slice(1) : "";
  const hp = new URLSearchParams(hash);

  const accessToken = hp.get("access_token") || "";
  const scopeFrag = hp.get("scope") || "";
  const state = hp.get("state") || "";
  const tokenType = hp.get("token_type") || "bearer";

  // Errores pueden venir en query (?error=...&error_description=...)
  const err = qp.get("error") || "";
  const errDesc = qp.get("error_description") || "";

  // Estado principal
  (async () => {
    // Genera URL de login si ya hay Client ID puesto
    refreshAuthUrlBox();

    stateOutEl.textContent = state ? String(state) : "(—)";

    if (err) {
      badPill("Error OAuth");
      tokenBox.textContent = "(vacío)";
      ircPassBox.textContent = "(vacío)";
      scopeBox.textContent = "(vacío)";
      const desc = safeDecode(errDesc);
      showWarn(`<b>Error OAuth:</b> <code>${err}</code>${desc ? ` — ${desc}` : ""}<br/><br/>
        Si el error es <b>redirect_mismatch</b>, revisa que <b>redirect_uri</b> sea exactamente:<br/>
        <code>${cleanRedirectUri()}</code><br/>
        y que esté añadido en tu app → <b>OAuth Redirect URLs</b>.`);
      return;
    }

    if (!accessToken) {
      badPill("Sin token");
      tokenBox.textContent = "(vacío)";
      ircPassBox.textContent = "(vacío)";
      scopeBox.textContent = "(vacío)";
      clearMsg();
      showWarn(`No llegó <code>access_token</code>.<br/><br/>
        Pulsa <b>Abrir login Twitch</b> (derecha), o pega tu Client ID y genera la URL.<br/>
        Asegúrate de usar <code>response_type=token</code> y que el <code>redirect_uri</code> coincide EXACTO.`);
      return;
    }

    okPill("Token recibido ✅");
    tokenBox.textContent = accessToken;
    ircPassBox.textContent = `oauth:${accessToken}`;
    scopeBox.textContent = decodeScopesLikeTwitch(scopeFrag || "(sin scope)");
    clearMsg();

    // Check state si existe guardado
    try {
      const expected = sessionStorage.getItem("twitch_oauth_state") || "";
      if (expected && state && expected !== state) {
        showWarn(`⚠️ <b>State no coincide</b> (posible redirect viejo). Token capturado igualmente.`);
      }
    } catch (_) {}

    showGood(`Token recibido (<code>${tokenType || "bearer"}</code>).<br/>Validando…`);

    let validated = null;
    try {
      validated = await validateToken(accessToken);
      setValidatedInfo(validated);

      const sc = (validated && Array.isArray(validated.scopes)) ? validated.scopes.join(" ") : decodeScopesLikeTwitch(scopeFrag);
      const env = buildEnvBlock({
        access_token: accessToken,
        token_type: tokenType,
        scopes: sc,
        client_id: validated.client_id || "",
        user_id: validated.user_id || "",
        login: validated.login || "",
        expires_in: validated.expires_in || 0,
        target
      });
      envBox.textContent = env;

      // Export global para copiar JSON
      window.__RLC_OAUTH_EXPORT__ = {
        type: "TWITCH_OAUTH_TOKEN",
        target,
        access_token: accessToken,
        token_type: tokenType || "bearer",
        scopes: sc,
        state: state || "",
        user_id: validated.user_id ? String(validated.user_id) : "",
        login: validated.login ? String(validated.login) : "",
        client_id: validated.client_id ? String(validated.client_id) : "",
        expires_in: validated.expires_in || 0,
        irc_pass: `oauth:${accessToken}`,
        helix_headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Client-Id": validated.client_id ? String(validated.client_id) : ""
        }
      };

      showGood(
        `✅ Token validado.<br/>
         <b>User ID</b>: <code>${String(validated.user_id || "")}</code><br/>
         <b>Login</b>: <code>${String(validated.login || "")}</code><br/>
         <b>Client ID</b>: <code>${String(validated.client_id || "")}</code>`
      );
    } catch (e) {
      const msg = String(e?.message || e || "Error").slice(0, 240);
      showWarn(`Token recibido, pero <b>no se pudo validar</b>.<br/><code>${msg}</code><br/>
      Aun así puedes copiar el token y usarlo en tu panel.`);
      // Export parcial
      window.__RLC_OAUTH_EXPORT__ = {
        type: "TWITCH_OAUTH_TOKEN",
        target,
        access_token: accessToken,
        token_type: tokenType || "bearer",
        scopes: decodeScopesLikeTwitch(scopeFrag),
        state: state || "",
        irc_pass: `oauth:${accessToken}`
      };
      envBox.textContent = buildEnvBlock({
        access_token: accessToken,
        token_type: tokenType,
        scopes: decodeScopesLikeTwitch(scopeFrag),
        client_id: "",
        user_id: "",
        login: "",
        expires_in: 0,
        target
      });
    }

    // Devuelve al opener (tu control.html) si existe (MISMO ORIGIN)
    try {
      if (window.opener && window.opener !== window) {
        window.opener.postMessage(window.__RLC_OAUTH_EXPORT__, location.origin);
      }
    } catch (_) {}

    // Limpia el token de la barra
    clearTokenFromAddressBar();

    if (autoClose) {
      setTimeout(() => { try { window.close(); } catch(_){} }, 600);
    }
  })();
})();
</script>
</body>
</html>
